<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Pixel Campfire</title>
<style>
  html,body{margin:0;background:#000;overflow:hidden}
  #c{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}
  #hint{
    position:fixed;left:0;right:0;bottom:12px;
    text-align:center;color:#cfcfcf;font:12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial;
    opacity:.7;pointer-events:none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">화면을 한 번 터치하면 불꽃 소리가 시작됩니다</div>

<script>
(() => {
  // -----------------------------
  // 1) 픽셀 해상도(원본 캔버스)
  // -----------------------------
  const W = 240;   // 픽셀 아트 폭
  const H = 150;   // 픽셀 아트 높이
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const off = document.createElement('canvas');
  off.width = W; off.height = H;
  const octx = off.getContext('2d', { willReadFrequently:true });

  // 픽셀 버퍼
  const img = octx.createImageData(W, H);
  const data = img.data;

  function setPx(x,y,r,g,b,a=255){
    if (x<0||y<0||x>=W||y>=H) return;
    const i = (y*W+x)*4;
    data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=a;
  }
  function fillRect(x,y,w,h, c){
    for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) setPx(xx,yy,c[0],c[1],c[2],255);
  }
  function circle(cx,cy,rad,c){
    const r2=rad*rad;
    for(let y=cy-rad; y<=cy+rad; y++){
      for(let x=cx-rad; x<=cx+rad; x++){
        const dx=x-cx, dy=y-cy;
        if(dx*dx+dy*dy<=r2) setPx(x,y,c[0],c[1],c[2],255);
      }
    }
  }
  function ellipse(cx,cy,rx,ry,c){
    for(let y=cy-ry; y<=cy+ry; y++){
      for(let x=cx-rx; x<=cx+rx; x++){
        const dx=(x-cx)/rx, dy=(y-cy)/ry;
        if(dx*dx+dy*dy<=1) setPx(x,y,c[0],c[1],c[2],255);
      }
    }
  }
  function tri(x1,y1,x2,y2,x3,y3,c){
    // simple barycentric fill
    const minX=Math.floor(Math.min(x1,x2,x3)), maxX=Math.ceil(Math.max(x1,x2,x3));
    const minY=Math.floor(Math.min(y1,y2,y3)), maxY=Math.ceil(Math.max(y1,y2,y3));
    const area = (x2-x1)*(y3-y1)-(y2-y1)*(x3-x1);
    if(area===0) return;
    for(let y=minY; y<=maxY; y++){
      for(let x=minX; x<=maxX; x++){
        const w1 = ((x2-x1)*(y-y1)-(y2-y1)*(x-x1)) / area;
        const w2 = ((x3-x2)*(y-y2)-(y3-y2)*(x-x2)) / area;
        const w3 = ((x1-x3)*(y-y3)-(y1-y3)*(x-x3)) / area;
        if(w1>=0 && w2>=0 && w3>=0) setPx(x,y,c[0],c[1],c[2],255);
      }
    }
  }
  function line(x1,y1,x2,y2,c){
    let dx=Math.abs(x2-x1), sx=x1<x2?1:-1;
    let dy=-Math.abs(y2-y1), sy=y1<y2?1:-1;
    let err=dx+dy;
    while(true){
      setPx(x1,y1,c[0],c[1],c[2],255);
      if(x1===x2 && y1===y2) break;
      const e2=2*err;
      if(e2>=dy){ err+=dy; x1+=sx; }
      if(e2<=dx){ err+=dx; y1+=sy; }
    }
  }

  // -----------------------------
  // 2) 팔레트(고정 색)
  // -----------------------------
  const P = {
    sky1:[18,24,40],
    sky2:[40,60,92],
    sky3:[85,120,160],
    star:[230,235,255],
    forest:[8,10,14],
    ground:[20,18,16],
    ground2:[28,24,20],
    trollSkin:[170,130,110],
    trollHair:[70,65,60],
    cloth:[175,175,175],
    boot:[120,115,110],
    childHair:[200,175,80],
    childSkin:[190,150,130],
    childCloth:[120,140,150],
    shadow:[10,10,12],
    log:[90,65,45],
    ember:[255,190,90],
    flame1:[255,210,120],
    flame2:[255,160,60],
    flame3:[200,80,30],
    smoke:[70,85,110]
  };

  // -----------------------------
  // 3) 배경/캐릭터 "픽셀 그림" 생성
  //    (원본 그림을 파일로 쓰지 않고,
  //     분위기+구도만 픽셀로 재현)
  // -----------------------------
  const stars = (() => {
    // 고정 시드 느낌으로 별 위치 고정
    const s=[];
    let seed=1234567;
    const rnd=()=> (seed = (seed*48271)%2147483647)/2147483647;
    for(let i=0;i<80;i++){
      s.push([Math.floor(rnd()*W), Math.floor(rnd()*(H*0.55)), rnd()<0.15?2:1]);
    }
    return s;
  })();

  function drawStaticScene(){
    // sky gradient
    for(let y=0;y<H;y++){
      const t=y/(H*0.62);
      let c;
      if(t<0.5){
        const k=t/0.5;
        c=[
          Math.round(P.sky1[0]*(1-k)+P.sky2[0]*k),
          Math.round(P.sky1[1]*(1-k)+P.sky2[1]*k),
          Math.round(P.sky1[2]*(1-k)+P.sky2[2]*k)
        ];
      } else {
        const k=(t-0.5)/0.5;
        c=[
          Math.round(P.sky2[0]*(1-k)+P.sky3[0]*k),
          Math.round(P.sky2[1]*(1-k)+P.sky3[1]*k),
          Math.round(P.sky2[2]*(1-k)+P.sky3[2]*k)
        ];
      }
      for(let x=0;x<W;x++) setPx(x,y,c[0],c[1],c[2],255);
    }

    // stars
    for(const [x,y,s] of stars){
      setPx(x,y, ...P.star);
      if(s===2){ setPx(x+1,y, ...P.star); setPx(x,y+1, ...P.star); }
    }

    // distant forest silhouette
    for(let i=0;i<18;i++){
      const x = Math.floor(i*(W/18) + (i%2?4:0));
      const h = 30 + (i%3)*10;
      tri(x, Math.floor(H*0.62), x+18, Math.floor(H*0.62), x+9, Math.floor(H*0.62)-h, P.forest);
    }

    // ground
    fillRect(0, Math.floor(H*0.62), W, H, P.ground);
    // ground texture
    for(let y=Math.floor(H*0.62); y<H; y++){
      for(let x=0;x<W;x++){
        if(((x*13+y*7)&31)===0) setPx(x,y,...P.ground2);
      }
    }

    // lake/ice 느낌 (원본 분위기 참고)
    fillRect(Math.floor(W*0.50), Math.floor(H*0.64), Math.floor(W*0.35), Math.floor(H*0.10), [30,32,36]);
    fillRect(Math.floor(W*0.52), Math.floor(H*0.655), Math.floor(W*0.31), Math.floor(H*0.07), [18,20,24]);

    // 큰 트롤(대충 비율/자세)
    // 몸통/옷
    ellipse(Math.floor(W*0.32), Math.floor(H*0.76), 30, 22, P.cloth);
    ellipse(Math.floor(W*0.29), Math.floor(H*0.79), 26, 18, [140,140,140]);
    // 팔
    ellipse(Math.floor(W*0.26), Math.floor(H*0.78), 18, 10, P.cloth);
    ellipse(Math.floor(W*0.37), Math.floor(H*0.78), 18, 10, P.cloth);
    // 손(피부)
    ellipse(Math.floor(W*0.23), Math.floor(H*0.80), 10, 8, P.trollSkin);
    ellipse(Math.floor(W*0.40), Math.floor(H*0.80), 10, 8, P.trollSkin);

    // 다리/부츠
    ellipse(Math.floor(W*0.25), Math.floor(H*0.88), 16, 10, P.boot);
    ellipse(Math.floor(W*0.36), Math.floor(H*0.88), 16, 10, P.boot);

    // 머리
    ellipse(Math.floor(W*0.30), Math.floor(H*0.68), 22, 18, P.trollSkin);
    // 코
    ellipse(Math.floor(W*0.33), Math.floor(H*0.70), 10, 7, [180,140,120]);
    // 눈
    circle(Math.floor(W*0.29), Math.floor(H*0.665), 2, [240,240,240]);
    circle(Math.floor(W*0.305), Math.floor(H*0.665), 1, [20,20,20]);

    // 머리카락/수염
    ellipse(Math.floor(W*0.29), Math.floor(H*0.67), 26, 22, P.trollHair);
    ellipse(Math.floor(W*0.28), Math.floor(H*0.74), 26, 16, P.trollHair);
    // 귀/귀걸이
    ellipse(Math.floor(W*0.27), Math.floor(H*0.69), 6, 7, [155,118,100]);
    circle(Math.floor(W*0.26), Math.floor(H*0.70), 3, [210,190,120]);
    circle(Math.floor(W*0.26), Math.floor(H*0.70), 2, P.trollHair);

    // 아이(트롤 앞)
    ellipse(Math.floor(W*0.33), Math.floor(H*0.83), 16, 12, P.childCloth);
    ellipse(Math.floor(W*0.33), Math.floor(H*0.80), 10, 9, P.childSkin);
    ellipse(Math.floor(W*0.33), Math.floor(H*0.78), 12, 10, P.childHair);
    // 아이 눈/코
    circle(Math.floor(W*0.325), Math.floor(H*0.795), 1, [240,240,240]);
    circle(Math.floor(W*0.33), Math.floor(H*0.795), 1, [20,20,20]);
    // 아이 팔 (막대기 들고)
    line(Math.floor(W*0.35), Math.floor(H*0.84), Math.floor(W*0.42), Math.floor(H*0.84), [110,90,60]);
    ellipse(Math.floor(W*0.35), Math.floor(H*0.84), 4, 3, P.childSkin);

    // 캠프파이어 자리(통나무+돌)
    fillRect(Math.floor(W*0.55)-10, Math.floor(H*0.90), 20, 6, [25,20,16]);
    ellipse(Math.floor(W*0.55), Math.floor(H*0.90), 12, 4, [25,20,16]);
    // 통나무
    ellipse(Math.floor(W*0.55)-6, Math.floor(H*0.885), 14, 4, P.log);
    ellipse(Math.floor(W*0.55)+6, Math.floor(H*0.885), 14, 4, P.log);
    // 꼬치 소시지
    line(Math.floor(W*0.41), Math.floor(H*0.84), Math.floor(W*0.57), Math.floor(H*0.83), [150,120,80]);
    ellipse(Math.floor(W*0.60), Math.floor(H*0.83), 8, 4, [190,120,90]);

    // 약한 연기 기둥(기본)
    for(let i=0;i<30;i++){
      const x = Math.floor(W*0.55 + Math.sin(i*0.35)*2);
      const y = Math.floor(H*0.86 - i*1.1);
      if(y<0) break;
      if((i%3)!==0) setPx(x,y,...P.smoke);
    }
  }

  // -----------------------------
  // 4) 불꽃 애니메이션 (불꽃만 움직임)
  // -----------------------------
  let t = 0;

  function drawFire(){
    // 불꽃 중심(픽셀 좌표) - 캠프파이어 위
    const cx = Math.floor(W*0.55);
    const cy = Math.floor(H*0.86);

    // flicker 파라미터
    const flick = 0.6 + 0.4*Math.sin(t*0.12) + 0.2*Math.sin(t*0.31);
    const height = Math.floor(22 + 8*flick);
    const width  = Math.floor(10 + 4*(1-flick));

    // 불꽃 영역을 "덧칠"
    for(let y=0; y<height; y++){
      const yy = cy - y;
      const w = Math.floor(width * (1 - y/height) * (0.7 + 0.5*Math.sin(t*0.1 + y*0.5)));
      for(let x=-w; x<=w; x++){
        const xx = cx + x;
        // shape mask (가운데가 더 뜨겁게)
        const core = 1 - (Math.abs(x)/(w+0.001));
        const heat = core*(1 - y/height);
        // 색 선택
        let c = P.flame3;
        if(heat>0.55) c = P.flame2;
        if(heat>0.75) c = P.flame1;

        // alpha 흉내: 배경과 섞기(간단 블렌드)
        const i = (yy*W+xx)*4;
        if(i<0 || i>=data.length) continue;
        const a = Math.max(0, Math.min(1, (0.25 + 0.75*heat) * (0.7 + 0.3*Math.sin(t*0.2 + x*0.9))));
        data[i]   = Math.round(data[i]  *(1-a) + c[0]*a);
        data[i+1] = Math.round(data[i+1]*(1-a) + c[1]*a);
        data[i+2] = Math.round(data[i+2]*(1-a) + c[2]*a);
        data[i+3] = 255;
      }
    }

    // 불씨(작은 점들)
    for(let k=0;k<8;k++){
      const ex = cx + Math.floor((Math.random()-0.5)*10);
      const ey = cy - Math.floor(Math.random()*10);
      if(Math.random()<0.6) setPx(ex,ey,...P.ember);
    }

    // 연기 움직임(아주 약하게)
    for(let i=0;i<26;i++){
      const x = Math.floor(cx + Math.sin((t*0.03)+i*0.35)*3);
      const y = Math.floor(cy - 10 - i*1.2);
      if(y<2) break;
      if((i + (t|0))%3===0){
        const ii=(y*W+x)*4;
        if(ii>=0 && ii<data.length){
          const a=0.18;
          data[ii]=Math.round(data[ii]*(1-a)+P.smoke[0]*a);
          data[ii+1]=Math.round(data[ii+1]*(1-a)+P.smoke[1]*a);
          data[ii+2]=Math.round(data[ii+2]*(1-a)+P.smoke[2]*a);
        }
      }
    }

    // 불빛이 얼굴/손에 살짝 반사(은은하게)
    const glowPts = [
      [Math.floor(W*0.30), Math.floor(H*0.68), 10], // 트롤 얼굴
      [Math.floor(W*0.33), Math.floor(H*0.80), 7],  // 아이 얼굴
      [Math.floor(W*0.23), Math.floor(H*0.80), 6],  // 트롤 손
    ];
    const glow = 0.10 + 0.10*Math.sin(t*0.2);
    for(const [gx,gy,gr] of glowPts){
      for(let y=gy-gr; y<=gy+gr; y++){
        for(let x=gx-gr; x<=gx+gr; x++){
          const dx=x-gx, dy=y-gy;
          if(dx*dx+dy*dy>gr*gr) continue;
          const ii=(y*W+x)*4;
          if(ii<0||ii>=data.length) continue;
          const a = glow*(1 - (dx*dx+dy*dy)/(gr*gr));
          data[ii]   = Math.min(255, Math.round(data[ii]  + 255*a));
          data[ii+1] = Math.min(255, Math.round(data[ii+1]+ 160*a));
          data[ii+2] = Math.min(255, Math.round(data[ii+2]+  60*a));
        }
      }
    }
  }

  // -----------------------------
  // 5) 렌더 루프 (픽셀 그대로 확대)
  // -----------------------------
  function resize(){
    canvas.width = innerWidth * devicePixelRatio;
    canvas.height = innerHeight * devicePixelRatio;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', resize);
  resize();

  function render(){
    // 매 프레임: 정적 장면 다시 그리고 불꽃만 덧칠
    // (정적+동적 분리하면 더 빠르지만, 여기선 단순/확실하게)
    data.fill(0);
    drawStaticScene();
    drawFire();

    octx.putImageData(img, 0, 0);

    // 화면에 비율 유지해서 크게 그리기
    ctx.clearRect(0,0,innerWidth,innerHeight);
    const scale = Math.floor(Math.min(innerWidth/W, innerHeight/H));
    const s = Math.max(2, scale); // 최소 2배
    const dw = W*s, dh = H*s;
    const dx = Math.floor((innerWidth - dw)/2);
    const dy = Math.floor((innerHeight - dh)/2);

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(off, dx, dy, dw, dh);

    t++;
    requestAnimationFrame(render);
  }
  render();

  // -----------------------------
  // 6) "타닥타닥" 웹오디오 (외부 mp3 없이)
  //    - 사파리 자동재생 제한 때문에 '터치'로 시작
  // -----------------------------
  let audioStarted = false;
  let ac, master, noiseBuf, noiseSrc, crackleGain;

  function startAudio(){
    if(audioStarted) return;
    audioStarted = true;
    document.getElementById('hint').style.display = 'none';

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    ac = new AudioContext();

    master = ac.createGain();
    master.gain.value = 0.18; // "조용한 느낌"
    master.connect(ac.destination);

    // 노이즈 버퍼 만들기
    const seconds = 2.0;
    noiseBuf = ac.createBuffer(1, ac.sampleRate * seconds, ac.sampleRate);
    const ch = noiseBuf.getChannelData(0);
    for(let i=0;i<ch.length;i++){
      // 살짝 부드러운 노이즈
      ch[i] = (Math.random()*2-1) * 0.6;
    }

    // 기본 '불꽃' 러시(저주파 제거 + 중고역 강조)
    noiseSrc = ac.createBufferSource();
    noiseSrc.buffer = noiseBuf;
    noiseSrc.loop = true;

    const hp = ac.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 700;

    const bp = ac.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1800;
    bp.Q.value = 0.8;

    crackleGain = ac.createGain();
    crackleGain.gain.value = 0.30;

    noiseSrc.connect(hp);
    hp.connect(bp);
    bp.connect(crackleGain);
    crackleGain.connect(master);

    noiseSrc.start();

    // 타닥 "팝" 랜덤 버스트
    const popGain = ac.createGain();
    popGain.gain.value = 0.0;
    popGain.connect(master);

    const popFilter = ac.createBiquadFilter();
    popFilter.type = 'bandpass';
    popFilter.frequency.value = 2400;
    popFilter.Q.value = 4.0;

    function schedulePop(){
      if(!ac) return;
      const now = ac.currentTime;

      // 다음 팝 시간 (조용하고 간헐적)
      const dt = 0.08 + Math.random()*0.35;
      const t0 = now + dt;

      // 짧은 버스트
      const src = ac.createBufferSource();
      src.buffer = noiseBuf;
      src.loop = false;

      const g = ac.createGain();
      g.gain.setValueAtTime(0.0, t0);
      const amp = 0.02 + Math.random()*0.06; // 팝 크기
      g.gain.linearRampToValueAtTime(amp, t0 + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.04 + Math.random()*0.05);

      src.connect(popFilter);
      popFilter.connect(g);
      g.connect(master);

      src.start(t0);
      src.stop(t0 + 0.2);

      setTimeout(schedulePop, Math.floor(dt*1000));
    }
    schedulePop();
  }

  // iOS Safari: user gesture 필요
  document.addEventListener('pointerdown', () => {
    startAudio();
  }, { once:true });

})();
</script>
</body>
</html>
